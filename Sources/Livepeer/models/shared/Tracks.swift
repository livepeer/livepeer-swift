// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

extension Shared {
    /// A model object
    public struct Tracks {
        /// Codec of the track
        public let codec: String
        /// type of track
        public let type: Shared.AssetSchemasVideoSpecType
        /// Bit depth of the track - only for audio tracks
        @DecimalSerialized
        public private(set) var bitDepth: Double?
        /// Bitrate of the track in bits per second
        @DecimalSerialized
        public private(set) var bitrate: Double?
        /// Amount of audio channels in the track
        @DecimalSerialized
        public private(set) var channels: Double?
        /// Duration of the track in seconds
        @DecimalSerialized
        public private(set) var duration: Double?
        /// Frame rate of the track - only for video tracks
        @DecimalSerialized
        public private(set) var fps: Double?
        /// Height of the track - only for video tracks
        @DecimalSerialized
        public private(set) var height: Double?
        /// Pixel format of the track - only for video tracks
        public let pixelFormat: String?
        /// Sample rate of the track in samples per second - only for
        /// audio tracks
        /// 
        @DecimalSerialized
        public private(set) var sampleRate: Double?
        /// Start time of the track in seconds
        @DecimalSerialized
        public private(set) var startTime: Double?
        /// Width of the track - only for video tracks
        @DecimalSerialized
        public private(set) var width: Double?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter codec: Codec of the track
        /// - Parameter type: type of track
        /// - Parameter bitDepth: Bit depth of the track - only for audio tracks
        /// - Parameter bitrate: Bitrate of the track in bits per second
        /// - Parameter channels: Amount of audio channels in the track
        /// - Parameter duration: Duration of the track in seconds
        /// - Parameter fps: Frame rate of the track - only for video tracks
        /// - Parameter height: Height of the track - only for video tracks
        /// - Parameter pixelFormat: Pixel format of the track - only for video tracks
        /// - Parameter sampleRate: Sample rate of the track in samples per second - only for
        /// audio tracks
        /// 
        /// - Parameter startTime: Start time of the track in seconds
        /// - Parameter width: Width of the track - only for video tracks
        ///
        public init(codec: String, type: Shared.AssetSchemasVideoSpecType, bitDepth: Double? = nil, bitrate: Double? = nil, channels: Double? = nil, duration: Double? = nil, fps: Double? = nil, height: Double? = nil, pixelFormat: String? = nil, sampleRate: Double? = nil, startTime: Double? = nil, width: Double? = nil) {
            self.codec = codec
            self.type = type
            self._bitDepth = DecimalSerialized<Double?>(wrappedValue: bitDepth)
            self._bitrate = DecimalSerialized<Double?>(wrappedValue: bitrate)
            self._channels = DecimalSerialized<Double?>(wrappedValue: channels)
            self._duration = DecimalSerialized<Double?>(wrappedValue: duration)
            self._fps = DecimalSerialized<Double?>(wrappedValue: fps)
            self._height = DecimalSerialized<Double?>(wrappedValue: height)
            self.pixelFormat = pixelFormat
            self._sampleRate = DecimalSerialized<Double?>(wrappedValue: sampleRate)
            self._startTime = DecimalSerialized<Double?>(wrappedValue: startTime)
            self._width = DecimalSerialized<Double?>(wrappedValue: width)
        }
    }
}

extension Shared.Tracks: Codable {
    enum CodingKeys: String, CodingKey {
        case codec
        case type
        case bitDepth
        case bitrate
        case channels
        case duration
        case fps
        case height
        case pixelFormat
        case sampleRate
        case startTime
        case width
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.codec = try container.decode(String.self, forKey: .codec)
        self.type = try container.decode(Shared.AssetSchemasVideoSpecType.self, forKey: .type)
        self._bitDepth = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .bitDepth) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._bitrate = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .bitrate) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._channels = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .channels) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._duration = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .duration) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._fps = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .fps) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._height = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .height) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.pixelFormat = try container.decodeIfPresent(String.self, forKey: .pixelFormat)
        self._sampleRate = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .sampleRate) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._startTime = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .startTime) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._width = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .width) ?? DecimalSerialized<Double?>(wrappedValue: nil)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.codec, forKey: .codec)
        try container.encode(self.type, forKey: .type)
        if self.bitDepth != nil {
            try container.encode(self._bitDepth, forKey: .bitDepth)
        }
        if self.bitrate != nil {
            try container.encode(self._bitrate, forKey: .bitrate)
        }
        if self.channels != nil {
            try container.encode(self._channels, forKey: .channels)
        }
        if self.duration != nil {
            try container.encode(self._duration, forKey: .duration)
        }
        if self.fps != nil {
            try container.encode(self._fps, forKey: .fps)
        }
        if self.height != nil {
            try container.encode(self._height, forKey: .height)
        }
        try container.encodeIfPresent(self.pixelFormat, forKey: .pixelFormat)
        if self.sampleRate != nil {
            try container.encode(self._sampleRate, forKey: .sampleRate)
        }
        if self.startTime != nil {
            try container.encode(self._startTime, forKey: .startTime)
        }
        if self.width != nil {
            try container.encode(self._width, forKey: .width)
        }
    }
}

extension Shared.Tracks {
    var startTimeWrapper: DecimalSerialized<Double?> {
        return _startTime
    }
    var durationWrapper: DecimalSerialized<Double?> {
        return _duration
    }
    var bitrateWrapper: DecimalSerialized<Double?> {
        return _bitrate
    }
    var widthWrapper: DecimalSerialized<Double?> {
        return _width
    }
    var heightWrapper: DecimalSerialized<Double?> {
        return _height
    }
    var fpsWrapper: DecimalSerialized<Double?> {
        return _fps
    }
    var channelsWrapper: DecimalSerialized<Double?> {
        return _channels
    }
    var sampleRateWrapper: DecimalSerialized<Double?> {
        return _sampleRate
    }
    var bitDepthWrapper: DecimalSerialized<Double?> {
        return _bitDepth
    }
}
