// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

extension Shared {
    /// A model object
    public struct Stream {
        public let name: String
        /// Timestamp (in milliseconds) at which the stream object was created
        @DecimalSerialized
        public private(set) var createdAt: Double?
        /// Name of the token used to create this object
        public let createdByTokenName: String?
        public let creatorId: Shared.CreatorId?
        public let id: String?
        /// Rate at which sourceBytes increases (bytes/second)
        @DecimalSerialized
        public private(set) var ingestRate: Double?
        /// If currently active
        public let isActive: Bool?
        /// Indicates whether the stream is healthy or not.
        public let isHealthy: Bool?
        /// A string array of human-readable errors describing issues affecting
        /// the stream, if any.
        /// 
        public let issues: [String]?
        @DecimalSerialized
        public private(set) var lastSeen: Double?
        public let multistream: Shared.StreamMultistream?
        /// Rate at which transcodedBytes increases (bytes/second)
        @DecimalSerialized
        public private(set) var outgoingRate: Double?
        /// Points to the parent stream object
        public let parentId: String?
        /// Used to form playback URL
        public let playbackId: String?
        /// Whether the playback policy for a asset or stream is public or signed
        public let playbackPolicy: Shared.PlaybackPolicy?
        public let profiles: [Shared.FfmpegProfile]?
        /// Should this stream be recorded? Uses default settings. For more
        /// customization, create and configure an object store.
        /// 
        public let record: Bool?
        @DecimalSerialized
        public private(set) var sourceBytes: Double?
        @DecimalSerialized
        public private(set) var sourceSegments: Double?
        /// Duration of all the source segments, sec
        @DecimalSerialized
        public private(set) var sourceSegmentsDuration: Double?
        /// Used to form the RTMP ingest URL
        public let streamKey: String?
        /// If currently suspended
        public let suspended: Bool?
        @DecimalSerialized
        public private(set) var transcodedBytes: Double?
        @DecimalSerialized
        public private(set) var transcodedSegments: Double?
        /// Duration of all the transcoded segments, sec
        @DecimalSerialized
        public private(set) var transcodedSegmentsDuration: Double?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter createdAt: Timestamp (in milliseconds) at which the stream object was created
        /// - Parameter createdByTokenName: Name of the token used to create this object
        /// - Parameter ingestRate: Rate at which sourceBytes increases (bytes/second)
        /// - Parameter isActive: If currently active
        /// - Parameter isHealthy: Indicates whether the stream is healthy or not.
        /// - Parameter issues: A string array of human-readable errors describing issues affecting
        /// the stream, if any.
        /// 
        /// - Parameter outgoingRate: Rate at which transcodedBytes increases (bytes/second)
        /// - Parameter parentId: Points to the parent stream object
        /// - Parameter playbackId: Used to form playback URL
        /// - Parameter playbackPolicy: Whether the playback policy for a asset or stream is public or signed
        /// - Parameter record: Should this stream be recorded? Uses default settings. For more
        /// customization, create and configure an object store.
        /// 
        /// - Parameter sourceSegmentsDuration: Duration of all the source segments, sec
        /// - Parameter streamKey: Used to form the RTMP ingest URL
        /// - Parameter suspended: If currently suspended
        /// - Parameter transcodedSegmentsDuration: Duration of all the transcoded segments, sec
        ///
        public init(name: String, createdAt: Double? = nil, createdByTokenName: String? = nil, creatorId: Shared.CreatorId? = nil, id: String? = nil, ingestRate: Double? = nil, isActive: Bool? = nil, isHealthy: Bool? = nil, issues: [String]? = nil, lastSeen: Double? = nil, multistream: Shared.StreamMultistream? = nil, outgoingRate: Double? = nil, parentId: String? = nil, playbackId: String? = nil, playbackPolicy: Shared.PlaybackPolicy? = nil, profiles: [Shared.FfmpegProfile]? = nil, record: Bool? = nil, sourceBytes: Double? = nil, sourceSegments: Double? = nil, sourceSegmentsDuration: Double? = nil, streamKey: String? = nil, suspended: Bool? = nil, transcodedBytes: Double? = nil, transcodedSegments: Double? = nil, transcodedSegmentsDuration: Double? = nil) {
            self.name = name
            self._createdAt = DecimalSerialized<Double?>(wrappedValue: createdAt)
            self.createdByTokenName = createdByTokenName
            self.creatorId = creatorId
            self.id = id
            self._ingestRate = DecimalSerialized<Double?>(wrappedValue: ingestRate)
            self.isActive = isActive
            self.isHealthy = isHealthy
            self.issues = issues
            self._lastSeen = DecimalSerialized<Double?>(wrappedValue: lastSeen)
            self.multistream = multistream
            self._outgoingRate = DecimalSerialized<Double?>(wrappedValue: outgoingRate)
            self.parentId = parentId
            self.playbackId = playbackId
            self.playbackPolicy = playbackPolicy
            self.profiles = profiles
            self.record = record
            self._sourceBytes = DecimalSerialized<Double?>(wrappedValue: sourceBytes)
            self._sourceSegments = DecimalSerialized<Double?>(wrappedValue: sourceSegments)
            self._sourceSegmentsDuration = DecimalSerialized<Double?>(wrappedValue: sourceSegmentsDuration)
            self.streamKey = streamKey
            self.suspended = suspended
            self._transcodedBytes = DecimalSerialized<Double?>(wrappedValue: transcodedBytes)
            self._transcodedSegments = DecimalSerialized<Double?>(wrappedValue: transcodedSegments)
            self._transcodedSegmentsDuration = DecimalSerialized<Double?>(wrappedValue: transcodedSegmentsDuration)
        }
    }
}

extension Shared.Stream: Codable {
    enum CodingKeys: String, CodingKey {
        case name
        case createdAt
        case createdByTokenName
        case creatorId
        case id
        case ingestRate
        case isActive
        case isHealthy
        case issues
        case lastSeen
        case multistream
        case outgoingRate
        case parentId
        case playbackId
        case playbackPolicy
        case profiles
        case record
        case sourceBytes
        case sourceSegments
        case sourceSegmentsDuration
        case streamKey
        case suspended
        case transcodedBytes
        case transcodedSegments
        case transcodedSegmentsDuration
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decode(String.self, forKey: .name)
        self._createdAt = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .createdAt) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.createdByTokenName = try container.decodeIfPresent(String.self, forKey: .createdByTokenName)
        self.creatorId = try container.decodeIfPresent(Shared.CreatorId.self, forKey: .creatorId)
        self.id = try container.decodeIfPresent(String.self, forKey: .id)
        self._ingestRate = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .ingestRate) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.isActive = try container.decodeIfPresent(Bool.self, forKey: .isActive)
        self.isHealthy = try container.decodeIfPresent(Bool.self, forKey: .isHealthy)
        self.issues = try container.decodeIfPresent([String].self, forKey: .issues)
        self._lastSeen = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .lastSeen) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.multistream = try container.decodeIfPresent(Shared.StreamMultistream.self, forKey: .multistream)
        self._outgoingRate = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .outgoingRate) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.parentId = try container.decodeIfPresent(String.self, forKey: .parentId)
        self.playbackId = try container.decodeIfPresent(String.self, forKey: .playbackId)
        self.playbackPolicy = try container.decodeIfPresent(Shared.PlaybackPolicy.self, forKey: .playbackPolicy)
        self.profiles = try container.decodeIfPresent([Shared.FfmpegProfile].self, forKey: .profiles)
        self.record = try container.decodeIfPresent(Bool.self, forKey: .record)
        self._sourceBytes = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .sourceBytes) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._sourceSegments = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .sourceSegments) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._sourceSegmentsDuration = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .sourceSegmentsDuration) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.streamKey = try container.decodeIfPresent(String.self, forKey: .streamKey)
        self.suspended = try container.decodeIfPresent(Bool.self, forKey: .suspended)
        self._transcodedBytes = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .transcodedBytes) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._transcodedSegments = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .transcodedSegments) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._transcodedSegmentsDuration = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .transcodedSegmentsDuration) ?? DecimalSerialized<Double?>(wrappedValue: nil)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.name, forKey: .name)
        if self.createdAt != nil {
            try container.encode(self._createdAt, forKey: .createdAt)
        }
        try container.encodeIfPresent(self.createdByTokenName, forKey: .createdByTokenName)
        try container.encodeIfPresent(self.creatorId, forKey: .creatorId)
        try container.encodeIfPresent(self.id, forKey: .id)
        if self.ingestRate != nil {
            try container.encode(self._ingestRate, forKey: .ingestRate)
        }
        try container.encodeIfPresent(self.isActive, forKey: .isActive)
        try container.encodeIfPresent(self.isHealthy, forKey: .isHealthy)
        try container.encodeIfPresent(self.issues, forKey: .issues)
        if self.lastSeen != nil {
            try container.encode(self._lastSeen, forKey: .lastSeen)
        }
        try container.encodeIfPresent(self.multistream, forKey: .multistream)
        if self.outgoingRate != nil {
            try container.encode(self._outgoingRate, forKey: .outgoingRate)
        }
        try container.encodeIfPresent(self.parentId, forKey: .parentId)
        try container.encodeIfPresent(self.playbackId, forKey: .playbackId)
        try container.encodeIfPresent(self.playbackPolicy, forKey: .playbackPolicy)
        try container.encodeIfPresent(self.profiles, forKey: .profiles)
        try container.encodeIfPresent(self.record, forKey: .record)
        if self.sourceBytes != nil {
            try container.encode(self._sourceBytes, forKey: .sourceBytes)
        }
        if self.sourceSegments != nil {
            try container.encode(self._sourceSegments, forKey: .sourceSegments)
        }
        if self.sourceSegmentsDuration != nil {
            try container.encode(self._sourceSegmentsDuration, forKey: .sourceSegmentsDuration)
        }
        try container.encodeIfPresent(self.streamKey, forKey: .streamKey)
        try container.encodeIfPresent(self.suspended, forKey: .suspended)
        if self.transcodedBytes != nil {
            try container.encode(self._transcodedBytes, forKey: .transcodedBytes)
        }
        if self.transcodedSegments != nil {
            try container.encode(self._transcodedSegments, forKey: .transcodedSegments)
        }
        if self.transcodedSegmentsDuration != nil {
            try container.encode(self._transcodedSegmentsDuration, forKey: .transcodedSegmentsDuration)
        }
    }
}

extension Shared.Stream {
    var lastSeenWrapper: DecimalSerialized<Double?> {
        return _lastSeen
    }
    var sourceSegmentsWrapper: DecimalSerialized<Double?> {
        return _sourceSegments
    }
    var transcodedSegmentsWrapper: DecimalSerialized<Double?> {
        return _transcodedSegments
    }
    var sourceSegmentsDurationWrapper: DecimalSerialized<Double?> {
        return _sourceSegmentsDuration
    }
    var transcodedSegmentsDurationWrapper: DecimalSerialized<Double?> {
        return _transcodedSegmentsDuration
    }
    var sourceBytesWrapper: DecimalSerialized<Double?> {
        return _sourceBytes
    }
    var transcodedBytesWrapper: DecimalSerialized<Double?> {
        return _transcodedBytes
    }
    var ingestRateWrapper: DecimalSerialized<Double?> {
        return _ingestRate
    }
    var outgoingRateWrapper: DecimalSerialized<Double?> {
        return _outgoingRate
    }
    var createdAtWrapper: DecimalSerialized<Double?> {
        return _createdAt
    }
}
