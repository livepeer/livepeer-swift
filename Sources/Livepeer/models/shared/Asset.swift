// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

extension Shared {
    /// A model object
    public struct Asset {
        public let id: String
        /// Name of the asset. This is not necessarily the filename, can be a
        /// custom name or title
        /// 
        public let name: String
        public let source: Shared.Source
        /// Timestamp (in milliseconds) at which asset was created
        @DecimalSerialized
        public private(set) var createdAt: Double?
        public let creatorId: Shared.CreatorId?
        /// URL to manually download the asset if desired
        public let downloadUrl: String?
        /// Hash of the asset
        public let hash: [Shared.Hash]?
        /// Used to form playback URL and storage folder
        public let playbackId: String?
        /// Whether the playback policy for a asset or stream is public or signed
        public let playbackPolicy: Shared.PlaybackPolicy?
        /// URL for HLS playback
        public let playbackUrl: String?
        /// Size of the asset in bytes
        @DecimalSerialized
        public private(set) var size: Double?
        /// Status of the asset
        public let status: Shared.AssetStatus?
        public let storage: Shared.AssetStorage?
        /// Type of the asset.
        public let type: Shared.AssetType?
        /// Video metadata
        public let videoSpec: Shared.VideoSpec?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter name: Name of the asset. This is not necessarily the filename, can be a
        /// custom name or title
        /// 
        /// - Parameter createdAt: Timestamp (in milliseconds) at which asset was created
        /// - Parameter downloadUrl: URL to manually download the asset if desired
        /// - Parameter hash: Hash of the asset
        /// - Parameter playbackId: Used to form playback URL and storage folder
        /// - Parameter playbackPolicy: Whether the playback policy for a asset or stream is public or signed
        /// - Parameter playbackUrl: URL for HLS playback
        /// - Parameter size: Size of the asset in bytes
        /// - Parameter status: Status of the asset
        /// - Parameter type: Type of the asset.
        /// - Parameter videoSpec: Video metadata
        ///
        public init(id: String, name: String, source: Shared.Source, createdAt: Double? = nil, creatorId: Shared.CreatorId? = nil, downloadUrl: String? = nil, hash: [Shared.Hash]? = nil, playbackId: String? = nil, playbackPolicy: Shared.PlaybackPolicy? = nil, playbackUrl: String? = nil, size: Double? = nil, status: Shared.AssetStatus? = nil, storage: Shared.AssetStorage? = nil, type: Shared.AssetType? = nil, videoSpec: Shared.VideoSpec? = nil) {
            self.id = id
            self.name = name
            self.source = source
            self._createdAt = DecimalSerialized<Double?>(wrappedValue: createdAt)
            self.creatorId = creatorId
            self.downloadUrl = downloadUrl
            self.hash = hash
            self.playbackId = playbackId
            self.playbackPolicy = playbackPolicy
            self.playbackUrl = playbackUrl
            self._size = DecimalSerialized<Double?>(wrappedValue: size)
            self.status = status
            self.storage = storage
            self.type = type
            self.videoSpec = videoSpec
        }
    }
}

extension Shared.Asset: Codable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case source
        case createdAt
        case creatorId
        case downloadUrl
        case hash
        case playbackId
        case playbackPolicy
        case playbackUrl
        case size
        case status
        case storage
        case type
        case videoSpec
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try container.decode(String.self, forKey: .id)
        self.name = try container.decode(String.self, forKey: .name)
        self.source = try container.decode(Shared.Source.self, forKey: .source)
        self._createdAt = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .createdAt) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.creatorId = try container.decodeIfPresent(Shared.CreatorId.self, forKey: .creatorId)
        self.downloadUrl = try container.decodeIfPresent(String.self, forKey: .downloadUrl)
        self.hash = try container.decodeIfPresent([Shared.Hash].self, forKey: .hash)
        self.playbackId = try container.decodeIfPresent(String.self, forKey: .playbackId)
        self.playbackPolicy = try container.decodeIfPresent(Shared.PlaybackPolicy.self, forKey: .playbackPolicy)
        self.playbackUrl = try container.decodeIfPresent(String.self, forKey: .playbackUrl)
        self._size = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .size) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.status = try container.decodeIfPresent(Shared.AssetStatus.self, forKey: .status)
        self.storage = try container.decodeIfPresent(Shared.AssetStorage.self, forKey: .storage)
        self.type = try container.decodeIfPresent(Shared.AssetType.self, forKey: .type)
        self.videoSpec = try container.decodeIfPresent(Shared.VideoSpec.self, forKey: .videoSpec)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.id, forKey: .id)
        try container.encode(self.name, forKey: .name)
        try container.encode(self.source, forKey: .source)
        if self.createdAt != nil {
            try container.encode(self._createdAt, forKey: .createdAt)
        }
        try container.encodeIfPresent(self.creatorId, forKey: .creatorId)
        try container.encodeIfPresent(self.downloadUrl, forKey: .downloadUrl)
        try container.encodeIfPresent(self.hash, forKey: .hash)
        try container.encodeIfPresent(self.playbackId, forKey: .playbackId)
        try container.encodeIfPresent(self.playbackPolicy, forKey: .playbackPolicy)
        try container.encodeIfPresent(self.playbackUrl, forKey: .playbackUrl)
        if self.size != nil {
            try container.encode(self._size, forKey: .size)
        }
        try container.encodeIfPresent(self.status, forKey: .status)
        try container.encodeIfPresent(self.storage, forKey: .storage)
        try container.encodeIfPresent(self.type, forKey: .type)
        try container.encodeIfPresent(self.videoSpec, forKey: .videoSpec)
    }
}

extension Shared.Asset {
    var createdAtWrapper: DecimalSerialized<Double?> {
        return _createdAt
    }
    var sizeWrapper: DecimalSerialized<Double?> {
        return _size
    }
}
