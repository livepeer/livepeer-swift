// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

extension Shared {
    /// A model object
    public struct Session {
        public let name: String
        /// Timestamp (in milliseconds) at which stream object was created
        @DecimalSerialized
        public private(set) var createdAt: Double?
        public let id: String?
        /// Rate at which sourceBytes increases (bytes/second)
        @DecimalSerialized
        public private(set) var ingestRate: Double?
        /// Indicates whether the stream is healthy or not.
        public let isHealthy: Bool?
        /// A string array of human-readable errors describing issues affecting
        /// the stream, if any.
        /// 
        public let issues: [String]?
        @DecimalSerialized
        public private(set) var lastSeen: Double?
        /// URL for the stream session recording packaged in an mp4.
        public let mp4Url: String?
        /// Rate at which transcodedBytes increases (bytes/second)
        @DecimalSerialized
        public private(set) var outgoingRate: Double?
        /// Points to parent stream object
        public let parentId: String?
        /// Used to form playback URL
        public let playbackId: String?
        public let profiles: [Shared.FfmpegProfile]?
        /// Should this stream be recorded? Uses default settings. For more
        /// customization, create and configure an object store.
        /// 
        public let record: Bool?
        /// Status of the recording process of this stream session.
        public let recordingStatus: Shared.RecordingStatus?
        /// URL for accessing the recording of this stream session.
        public let recordingUrl: String?
        @DecimalSerialized
        public private(set) var sourceBytes: Double?
        @DecimalSerialized
        public private(set) var sourceSegments: Double?
        /// Duration of all the source segments, sec
        @DecimalSerialized
        public private(set) var sourceSegmentsDuration: Double?
        @DecimalSerialized
        public private(set) var transcodedBytes: Double?
        @DecimalSerialized
        public private(set) var transcodedSegments: Double?
        /// Duration of all the transcoded segments, sec
        @DecimalSerialized
        public private(set) var transcodedSegmentsDuration: Double?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter createdAt: Timestamp (in milliseconds) at which stream object was created
        /// - Parameter ingestRate: Rate at which sourceBytes increases (bytes/second)
        /// - Parameter isHealthy: Indicates whether the stream is healthy or not.
        /// - Parameter issues: A string array of human-readable errors describing issues affecting
        /// the stream, if any.
        /// 
        /// - Parameter mp4Url: URL for the stream session recording packaged in an mp4.
        /// - Parameter outgoingRate: Rate at which transcodedBytes increases (bytes/second)
        /// - Parameter parentId: Points to parent stream object
        /// - Parameter playbackId: Used to form playback URL
        /// - Parameter record: Should this stream be recorded? Uses default settings. For more
        /// customization, create and configure an object store.
        /// 
        /// - Parameter recordingStatus: Status of the recording process of this stream session.
        /// - Parameter recordingUrl: URL for accessing the recording of this stream session.
        /// - Parameter sourceSegmentsDuration: Duration of all the source segments, sec
        /// - Parameter transcodedSegmentsDuration: Duration of all the transcoded segments, sec
        ///
        public init(name: String, createdAt: Double? = nil, id: String? = nil, ingestRate: Double? = nil, isHealthy: Bool? = nil, issues: [String]? = nil, lastSeen: Double? = nil, mp4Url: String? = nil, outgoingRate: Double? = nil, parentId: String? = nil, playbackId: String? = nil, profiles: [Shared.FfmpegProfile]? = nil, record: Bool? = nil, recordingStatus: Shared.RecordingStatus? = nil, recordingUrl: String? = nil, sourceBytes: Double? = nil, sourceSegments: Double? = nil, sourceSegmentsDuration: Double? = nil, transcodedBytes: Double? = nil, transcodedSegments: Double? = nil, transcodedSegmentsDuration: Double? = nil) {
            self.name = name
            self._createdAt = DecimalSerialized<Double?>(wrappedValue: createdAt)
            self.id = id
            self._ingestRate = DecimalSerialized<Double?>(wrappedValue: ingestRate)
            self.isHealthy = isHealthy
            self.issues = issues
            self._lastSeen = DecimalSerialized<Double?>(wrappedValue: lastSeen)
            self.mp4Url = mp4Url
            self._outgoingRate = DecimalSerialized<Double?>(wrappedValue: outgoingRate)
            self.parentId = parentId
            self.playbackId = playbackId
            self.profiles = profiles
            self.record = record
            self.recordingStatus = recordingStatus
            self.recordingUrl = recordingUrl
            self._sourceBytes = DecimalSerialized<Double?>(wrappedValue: sourceBytes)
            self._sourceSegments = DecimalSerialized<Double?>(wrappedValue: sourceSegments)
            self._sourceSegmentsDuration = DecimalSerialized<Double?>(wrappedValue: sourceSegmentsDuration)
            self._transcodedBytes = DecimalSerialized<Double?>(wrappedValue: transcodedBytes)
            self._transcodedSegments = DecimalSerialized<Double?>(wrappedValue: transcodedSegments)
            self._transcodedSegmentsDuration = DecimalSerialized<Double?>(wrappedValue: transcodedSegmentsDuration)
        }
    }
}

extension Shared.Session: Codable {
    enum CodingKeys: String, CodingKey {
        case name
        case createdAt
        case id
        case ingestRate
        case isHealthy
        case issues
        case lastSeen
        case mp4Url
        case outgoingRate
        case parentId
        case playbackId
        case profiles
        case record
        case recordingStatus
        case recordingUrl
        case sourceBytes
        case sourceSegments
        case sourceSegmentsDuration
        case transcodedBytes
        case transcodedSegments
        case transcodedSegmentsDuration
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decode(String.self, forKey: .name)
        self._createdAt = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .createdAt) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.id = try container.decodeIfPresent(String.self, forKey: .id)
        self._ingestRate = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .ingestRate) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.isHealthy = try container.decodeIfPresent(Bool.self, forKey: .isHealthy)
        self.issues = try container.decodeIfPresent([String].self, forKey: .issues)
        self._lastSeen = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .lastSeen) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.mp4Url = try container.decodeIfPresent(String.self, forKey: .mp4Url)
        self._outgoingRate = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .outgoingRate) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.parentId = try container.decodeIfPresent(String.self, forKey: .parentId)
        self.playbackId = try container.decodeIfPresent(String.self, forKey: .playbackId)
        self.profiles = try container.decodeIfPresent([Shared.FfmpegProfile].self, forKey: .profiles)
        self.record = try container.decodeIfPresent(Bool.self, forKey: .record)
        self.recordingStatus = try container.decodeIfPresent(Shared.RecordingStatus.self, forKey: .recordingStatus)
        self.recordingUrl = try container.decodeIfPresent(String.self, forKey: .recordingUrl)
        self._sourceBytes = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .sourceBytes) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._sourceSegments = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .sourceSegments) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._sourceSegmentsDuration = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .sourceSegmentsDuration) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._transcodedBytes = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .transcodedBytes) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._transcodedSegments = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .transcodedSegments) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._transcodedSegmentsDuration = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .transcodedSegmentsDuration) ?? DecimalSerialized<Double?>(wrappedValue: nil)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.name, forKey: .name)
        if self.createdAt != nil {
            try container.encode(self._createdAt, forKey: .createdAt)
        }
        try container.encodeIfPresent(self.id, forKey: .id)
        if self.ingestRate != nil {
            try container.encode(self._ingestRate, forKey: .ingestRate)
        }
        try container.encodeIfPresent(self.isHealthy, forKey: .isHealthy)
        try container.encodeIfPresent(self.issues, forKey: .issues)
        if self.lastSeen != nil {
            try container.encode(self._lastSeen, forKey: .lastSeen)
        }
        try container.encodeIfPresent(self.mp4Url, forKey: .mp4Url)
        if self.outgoingRate != nil {
            try container.encode(self._outgoingRate, forKey: .outgoingRate)
        }
        try container.encodeIfPresent(self.parentId, forKey: .parentId)
        try container.encodeIfPresent(self.playbackId, forKey: .playbackId)
        try container.encodeIfPresent(self.profiles, forKey: .profiles)
        try container.encodeIfPresent(self.record, forKey: .record)
        try container.encodeIfPresent(self.recordingStatus, forKey: .recordingStatus)
        try container.encodeIfPresent(self.recordingUrl, forKey: .recordingUrl)
        if self.sourceBytes != nil {
            try container.encode(self._sourceBytes, forKey: .sourceBytes)
        }
        if self.sourceSegments != nil {
            try container.encode(self._sourceSegments, forKey: .sourceSegments)
        }
        if self.sourceSegmentsDuration != nil {
            try container.encode(self._sourceSegmentsDuration, forKey: .sourceSegmentsDuration)
        }
        if self.transcodedBytes != nil {
            try container.encode(self._transcodedBytes, forKey: .transcodedBytes)
        }
        if self.transcodedSegments != nil {
            try container.encode(self._transcodedSegments, forKey: .transcodedSegments)
        }
        if self.transcodedSegmentsDuration != nil {
            try container.encode(self._transcodedSegmentsDuration, forKey: .transcodedSegmentsDuration)
        }
    }
}

extension Shared.Session {
    var lastSeenWrapper: DecimalSerialized<Double?> {
        return _lastSeen
    }
    var sourceSegmentsWrapper: DecimalSerialized<Double?> {
        return _sourceSegments
    }
    var transcodedSegmentsWrapper: DecimalSerialized<Double?> {
        return _transcodedSegments
    }
    var sourceSegmentsDurationWrapper: DecimalSerialized<Double?> {
        return _sourceSegmentsDuration
    }
    var transcodedSegmentsDurationWrapper: DecimalSerialized<Double?> {
        return _transcodedSegmentsDuration
    }
    var sourceBytesWrapper: DecimalSerialized<Double?> {
        return _sourceBytes
    }
    var transcodedBytesWrapper: DecimalSerialized<Double?> {
        return _transcodedBytes
    }
    var ingestRateWrapper: DecimalSerialized<Double?> {
        return _ingestRate
    }
    var outgoingRateWrapper: DecimalSerialized<Double?> {
        return _outgoingRate
    }
    var createdAtWrapper: DecimalSerialized<Double?> {
        return _createdAt
    }
}
