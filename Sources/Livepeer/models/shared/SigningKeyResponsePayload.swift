// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

extension Shared {
    /// A model object
    public struct SigningKeyResponsePayload {
        public let privateKey: String
        public let publicKey: String
        /// Timestamp (in milliseconds) at which the signing-key was created
        @DecimalSerialized
        public private(set) var createdAt: Double?
        /// Disable the signing key to allow rotation safely
        public let disabled: Bool?
        public let id: String?
        /// Timestamp (in milliseconds) at which the signing-key was last used
        @DecimalSerialized
        public private(set) var lastSeen: Double?
        /// Name of the signing key
        public let name: String?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter createdAt: Timestamp (in milliseconds) at which the signing-key was created
        /// - Parameter disabled: Disable the signing key to allow rotation safely
        /// - Parameter lastSeen: Timestamp (in milliseconds) at which the signing-key was last used
        /// - Parameter name: Name of the signing key
        ///
        public init(privateKey: String, publicKey: String, createdAt: Double? = nil, disabled: Bool? = nil, id: String? = nil, lastSeen: Double? = nil, name: String? = nil) {
            self.privateKey = privateKey
            self.publicKey = publicKey
            self._createdAt = DecimalSerialized<Double?>(wrappedValue: createdAt)
            self.disabled = disabled
            self.id = id
            self._lastSeen = DecimalSerialized<Double?>(wrappedValue: lastSeen)
            self.name = name
        }
    }
}

extension Shared.SigningKeyResponsePayload: Codable {
    enum CodingKeys: String, CodingKey {
        case privateKey
        case publicKey
        case createdAt
        case disabled
        case id
        case lastSeen
        case name
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.privateKey = try container.decode(String.self, forKey: .privateKey)
        self.publicKey = try container.decode(String.self, forKey: .publicKey)
        self._createdAt = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .createdAt) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.disabled = try container.decodeIfPresent(Bool.self, forKey: .disabled)
        self.id = try container.decodeIfPresent(String.self, forKey: .id)
        self._lastSeen = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .lastSeen) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.name = try container.decodeIfPresent(String.self, forKey: .name)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.privateKey, forKey: .privateKey)
        try container.encode(self.publicKey, forKey: .publicKey)
        if self.createdAt != nil {
            try container.encode(self._createdAt, forKey: .createdAt)
        }
        try container.encodeIfPresent(self.disabled, forKey: .disabled)
        try container.encodeIfPresent(self.id, forKey: .id)
        if self.lastSeen != nil {
            try container.encode(self._lastSeen, forKey: .lastSeen)
        }
        try container.encodeIfPresent(self.name, forKey: .name)
    }
}

extension Shared.SigningKeyResponsePayload {
    var createdAtWrapper: DecimalSerialized<Double?> {
        return _createdAt
    }
    var lastSeenWrapper: DecimalSerialized<Double?> {
        return _lastSeen
    }
}
