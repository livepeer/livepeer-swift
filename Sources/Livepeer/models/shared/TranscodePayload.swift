// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

extension Shared {
    /// A model object
    public struct TranscodePayload {
        public let input: Shared.Input
        /// Output formats
        public let outputs: Shared.Outputs
        public let storage: Shared.TranscodePayloadStorage
        /// Decides if the output video should include C2PA signature
        public let c2pa: Bool?
        public let creatorId: Shared.InputCreatorId?
        public let profiles: [Shared.TranscodeProfile]?
        /// How many seconds the duration of each output segment should be
        @DecimalSerialized
        public private(set) var targetSegmentSizeSecs: Double?

        /// Creates an object with the specified parameters
        ///
        /// - Parameter outputs: Output formats
        /// - Parameter c2pa: Decides if the output video should include C2PA signature
        /// - Parameter targetSegmentSizeSecs: How many seconds the duration of each output segment should be
        ///
        public init(input: Shared.Input, outputs: Shared.Outputs, storage: Shared.TranscodePayloadStorage, c2pa: Bool? = nil, creatorId: Shared.InputCreatorId? = nil, profiles: [Shared.TranscodeProfile]? = nil, targetSegmentSizeSecs: Double? = nil) {
            self.input = input
            self.outputs = outputs
            self.storage = storage
            self.c2pa = c2pa
            self.creatorId = creatorId
            self.profiles = profiles
            self._targetSegmentSizeSecs = DecimalSerialized<Double?>(wrappedValue: targetSegmentSizeSecs)
        }
    }
}

extension Shared.TranscodePayload: Codable {
    enum CodingKeys: String, CodingKey {
        case input
        case outputs
        case storage
        case c2pa
        case creatorId
        case profiles
        case targetSegmentSizeSecs
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.input = try container.decode(Shared.Input.self, forKey: .input)
        self.outputs = try container.decode(Shared.Outputs.self, forKey: .outputs)
        self.storage = try container.decode(Shared.TranscodePayloadStorage.self, forKey: .storage)
        self.c2pa = try container.decodeIfPresent(Bool.self, forKey: .c2pa)
        self.creatorId = try container.decodeIfPresent(Shared.InputCreatorId.self, forKey: .creatorId)
        self.profiles = try container.decodeIfPresent([Shared.TranscodeProfile].self, forKey: .profiles)
        self._targetSegmentSizeSecs = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .targetSegmentSizeSecs) ?? DecimalSerialized<Double?>(wrappedValue: nil)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.input, forKey: .input)
        try container.encode(self.outputs, forKey: .outputs)
        try container.encode(self.storage, forKey: .storage)
        try container.encodeIfPresent(self.c2pa, forKey: .c2pa)
        try container.encodeIfPresent(self.creatorId, forKey: .creatorId)
        try container.encodeIfPresent(self.profiles, forKey: .profiles)
        if self.targetSegmentSizeSecs != nil {
            try container.encode(self._targetSegmentSizeSecs, forKey: .targetSegmentSizeSecs)
        }
    }
}

extension Shared.TranscodePayload {
    var targetSegmentSizeSecsWrapper: DecimalSerialized<Double?> {
        return _targetSegmentSizeSecs
    }
}
